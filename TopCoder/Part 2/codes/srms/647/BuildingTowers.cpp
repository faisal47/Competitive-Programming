#include <bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
#define inf 1<<28
#define mp make_pair
#define pii pair<int,int>
#define fs first
#define sc second
#define pob pop_back
#define vec_ vector
#define clr(a) a.clear()
#define pb push_back
#define eps 1E-7
#define all(a) a.begin(),a.end()
#define allr(a) a.rbegin(),a.rend()
#define fop   freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#define sz(a) (int)a.size()
#define ll long long
#define dd double
using namespace std;

template<class T1> void deb(T1 e)
{
    cout<<e<<endl;
}
template<class T1,class T2> void deb(T1 e1,T2 e2)
{
    cout<<e1<<" "<<e2<<endl;
}
template<class T1,class T2,class T3> void deb(T1 e1,T2 e2,T3 e3)
{
    cout<<e1<<" "<<e2<<" "<<e3<<endl;
}
template<class T1,class T2,class T3,class T4> void deb(T1 e1,T2 e2,T3 e3,T4 e4)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<endl;
}
template<class T1,class T2,class T3,class T4,class T5> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<endl;
}
template<class T1,class T2,class T3,class T4,class T5,class T6> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5,T6 e6)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<" "<<e6<<endl;
}
//template <class T> T lcm(T a, T b){return (a/__gcd(a,b)) * b;}
//ll bigmod(ll a,ll b,ll m){if(b == 0) return 1%m;ll x = bigmod(a,b/2,m);x = (x * x) % m;if(b % 2 == 1) x = (x * a) % m;return x;}
//double dur(int x1,int y1,int x2,int y2)
//{
//    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
//template<class T> string toString(T n){ostringstream oss;oss<<n;oss.flush();return oss.str();}
//int toInt(string s){int r=0;istringstream sin(s);sin>>r;return r;}
//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};
//int X[]={0,-1,-1,-1,0,1,1,1};
//int Y[]={-1,-1,0,1,1,1,0,-1};
//int X[]={-1,0,1,0};
//int Y[]={0,1,0,-1};

#define mt
#define mod

int n,dif;
vec_<int>arr1,arr2;

bool okay(ll mh)
{
    ll i,lt,ht,ha,steps,mhh,mnhh;
    for(i=0; i<sz(arr1)+1; i++)
    {
        if(i==0)
        {
            lt=1;
            ha=0;
            steps=(mh-ha)/dif;
            if((mh-ha)%dif > 0)
                steps++;

            ht=arr1[i];
        }
        else if(i==sz(arr1))
        {
            lt=arr1[i-1];
            ht=n;
            mnhh=arr2[i-1];
            mhh=arr2[n];

        }
        else
        {
            lt=arr1[i-1];
            ht=arr1[i];
            mnhh=arr2[i-1];
            mhh=arr2[i];
            if(mhh < mnhh)
                swap(mhh,mnhh);
            mhh=min(mhh,dif*(ht-lt)+mnhh);
            steps=(mh-mnhh)/dif;
            if((mh-mnhh)%dif > 0)
                steps++;
            lt+=steps;

        }
    }
    return 1;
}

ll bs()
{
    ll l=0,h=999999999000000000,mid;
    ll ret=0;
    while(l <= h)
    {
        mid=(l+h)/2;
        if(okay(mid))
        {
            ret=max(ret,mid);
            l=mid+1;
        }
        else
            h=mid-1;
    }
    return ret;
}

class BuildingTowers
{
public:
    long long maxHeight(int N, int K, vector <int> x, vector <int> t)
    {
        n=N;
        dif=K;
        arr1=x;
        arr2=t;
        return bs();
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <int> p2, vector <int> p3, bool hasAnswer, long long p4)
{
    cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
    for (int i = 0; int(p2.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p2[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p3.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p3[i];
    }
    cout << "}";
    cout << "]" << endl;
    BuildingTowers *obj;
    long long answer;
    obj = new BuildingTowers();
    clock_t startTime = clock();
    answer = obj->maxHeight(p0, p1, p2, p3);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p4 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p4;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    int p0;
    int p1;
    vector <int> p2;
    vector <int> p3;
    long long p4;

    {
        // ----- test 0 -----
        p0 = 10;
        p1 = 1;
        int t2[] = {3,8};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {1,1};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 3ll;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = 1000000000;
        p1 = 1000000000;
        p2.clear() /*{}*/;
        p3.clear() /*{}*/;
        p4 = 999999999000000000ll;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = 20;
        p1 = 3;
        int t2[] = {4,7,13,15,18};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {8,22,1,55,42};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 22ll;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = 780;
        p1 = 547990606;
        int t2[] = {34,35,48,86,110,170,275,288,313,321,344,373,390,410,412,441,499,525,538,568,585,627,630,671,692,699,719,752,755,764,772};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {89,81,88,42,55,92,19,91,71,42,72,18,86,89,88,75,29,98,63,74,45,11,68,34,94,20,69,33,50,69,54};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 28495511604ll;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        p0 = 7824078;
        p1 = 2374;
        int t2[] = {134668,488112,558756,590300,787884,868112,1550116,1681439,1790994,1796091,1906637,2005485,2152813,2171716,2255697,2332732,2516853,2749024,2922558,2930163,3568190,3882735,4264888,5080550,5167938,5249191,5574341,5866912,5936121,6142348,6164177,6176113,6434368,6552905,6588059,6628843,6744163,6760794,6982172,7080464,7175493,7249044};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {8,9,171315129,52304509,1090062,476157338,245,6,253638067,37,500,29060,106246500,129,22402,939993108,7375,2365707,40098,10200444,3193547,55597,24920935,905027,1374,12396141,525886,41,33,3692,11502,180,3186,5560,778988,42449532,269666,10982579,48,3994,1,9};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 1365130725ll;
        all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// The citizens of Byteland want to build N new buildings.
// The new buildings will all stand in a line and they will be labeled 1 through N, in order.
// The city regulations impose some restrictions on the heights of the new buildings.
// You are given the parameters used in these restrictions: an int K and two vector <int>s x and t.
// The restrictions are described below.
//
//
// The height of each building must be a nonnegative integer.
// The height of building 1 must be 0.
// The absolute value of the difference between any two adjacent buildings must be at most K.
// For each valid i, the height of building x[i] must be t[i] or less.
//
//
//
//
// Given these restrictions, the citizens of Byteland want to build a building that will be as tall as possible.
// Return the largest possible height some of the N buildings may have.
//
//
// DEFINITION
// Class:BuildingTowers
// Method:maxHeight
// Parameters:int, int, vector <int>, vector <int>
// Returns:long long
// Method signature:long long maxHeight(int N, int K, vector <int> x, vector <int> t)
//
//
// CONSTRAINTS
// -N will be between 1 and 1,000,000,000, inclusive.
// -K will be between 1 and 1,000,000,000, inclusive.
// -x will contain between 0 and min(N,500) elements, inclusive.
// -t will have exactly the same number of elements as x
// -Each element of x will be between 1 and N, inclusive.
// -x[i] < x[i+1] for all valid i.
// -Each element of t will be between 1 and 1,000,000,000, inclusive.
//
//
// EXAMPLES
//
// 0)
// 10
// 1
// {3,8}
// {1,1}
//
// Returns: 3
//
//
// In this case we are going to build 10 buildings.
// The difference in height between adjacent buildings is at most 1.
// We also have two additional constraints: the height of building 3 can be at most 1, and the height of building 8 can also be at most 1.
// The tallest possible new building in this city can have height 3.
// One optimal skyline looks as follows: {0,1,1,2,3,3,2,1,1,0}.
//
//
// 1)
// 1000000000
// 1000000000
// {}
// {}
//
// Returns: 999999999000000000
//
// There are no additional constraints so, for each valid i, the height of building i can be (i-1)*1000000000.
//
// 2)
// 20
// 3
// {4,7,13,15,18}
// {8,22,1,55,42}
//
// Returns: 22
//
//
//
// 3)
// 780
// 547990606
// {34,35,48,86,110,170,275,288,313,321,344,373,390,410,412,441,499,525,538,568,585,627,630,671,692,699,719,752,755,764,772}
// {89,81,88,42,55,92,19,91,71,42,72,18,86,89,88,75,29,98,63,74,45,11,68,34,94,20,69,33,50,69,54}
//
// Returns: 28495511604
//
//
//
// 4)
// 7824078
// 2374
// {134668,488112,558756,590300,787884,868112,1550116,1681439,1790994,
// 1796091,1906637,2005485,2152813,2171716,2255697,2332732,2516853,
// 2749024,2922558,2930163,3568190,3882735,4264888,5080550,5167938,
// 5249191,5574341,5866912,5936121,6142348,6164177,6176113,6434368,
// 6552905,6588059,6628843,6744163,6760794,6982172,7080464,7175493,
// 7249044}
// {8,9,171315129,52304509,1090062,476157338,245,6,253638067,37,500,
// 29060,106246500,129,22402,939993108,7375,2365707,40098,10200444,
// 3193547,55597,24920935,905027,1374,12396141,525886,41,33,3692,
// 11502,180,3186,5560,778988,42449532,269666,10982579,48,3994,1,9}
//
// Returns: 1365130725
//
//
//
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
