#include <bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
#define inf 1<<28
#define mp make_pair
#define pii pair<int,int>
#define fs first
#define sc second
#define pob pop_back
#define vec_ vector
#define clr(a) a.clear()
#define pb push_back
#define eps 1E-7
#define all(a) a.begin(),a.end()
#define allr(a) a.rbegin(),a.rend()
#define fop   freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#define sz(a) (int)a.size()
#define ll long long
#define dd double
using namespace std;

template<class T1> void deb(T1 e){cout<<e<<endl;}
template<class T1,class T2> void deb(T1 e1,T2 e2){cout<<e1<<" "<<e2<<endl;}
template<class T1,class T2,class T3> void deb(T1 e1,T2 e2,T3 e3){cout<<e1<<" "<<e2<<" "<<e3<<endl;}
template<class T1,class T2,class T3,class T4> void deb(T1 e1,T2 e2,T3 e3,T4 e4){cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<endl;}
template<class T1,class T2,class T3,class T4,class T5> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5){cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<endl;}
template<class T1,class T2,class T3,class T4,class T5,class T6> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5,T6 e6){cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<" "<<e6<<endl;}
//template <class T> T lcm(T a, T b){return (a/__gcd(a,b)) * b;}
//ll bigmod(ll a,ll b,ll m){if(b == 0) return 1%m;ll x = bigmod(a,b/2,m);x = (x * x) % m;if(b % 2 == 1) x = (x * a) % m;return x;}
//double dur(int x1,int y1,int x2,int y2)
//{
//    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
//template<class T> string toString(T n){ostringstream oss;oss<<n;oss.flush();return oss.str();}
//int toInt(string s){int r=0;istringstream sin(s);sin>>r;return r;}
//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};
//int X[]={0,-1,-1,-1,0,1,1,1};
//int Y[]={-1,-1,0,1,1,1,0,-1};
//int X[]={-1,0,1,0};
//int Y[]={0,1,0,-1};

#define mt
#define mod

struct maan
{
    ll s,e;
};

vec_<maan>v;

bool comp(maan a,maan b)
{
    return a.s<b.s;
}

ll solve2(ll ind)
{
    ll ret=0;
    for(int i=0;i<sz(v);i++)
    {
        ret+=abs(v[i].s-ind);
        ind+=v[i].e;
    }
    return ret;
}

ll solve()
{
    ll l=1ll,h=3*(1e9),mid1,mid2,maan1,maan2;
    ll ret=(1ll<<50);
    for(int i=0;i<200;i++)
    {
        if(l>=h)
            break;

        mid1=(2ll*l+h)/3;
        mid2=(l+2ll*h)/3;
        maan1=solve2(mid1);
        maan2=solve2(mid2);
        if(maan1 <= maan2)
        {
            h=mid2;
            ret=min(ret,maan1);
        }
        else
        {
            l=mid1;
            ret=min(ret,maan2);
        }
    }

    return ret;
}

class ConnectingCars {
public:
	long long minimizeCost(vector <int>a, vector <int> b) {
		clr(v);
		int i;
		for(i=0;i<sz(a);i++)
        v.pb({a[i],b[i]});
        sort(all(v),comp);
        return solve();
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, long long p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	ConnectingCars *obj;
	long long answer;
	obj = new ConnectingCars();
	clock_t startTime = clock();
	answer = obj->minimizeCost(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	vector <int> p1;
	long long p2;

	{
	// ----- test 0 -----
	int t0[] = {1,3,10,20};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {2,2,5,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 15ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	int t0[] = {100,50,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {10,2,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 96ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	int t0[] = {4,10,100,13,80};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {5,3,42,40,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 66ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	int t0[] = {5606451,63581020,81615191,190991272,352848147,413795385,468408016,615921162,760622952,791438427};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {42643329,9909484,58137134,99547272,39849232,15146704,144630245,604149,15591965,107856540};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1009957100ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Janusz works in roller coaster maintenance.
// The station of the roller coaster is a long straight segment of railroad tracks.
// There are some cars on those tracks.
// The cars are currently not attached to each other, and there may be gaps between some of them.
// Janusz has to push them all together and connect them into a train.
//
// You are given the vector <int>s positions and lengths.
// For each valid i, there is a car that is lengths[i] meters long and starts positions[i] meters from the beginning of the station.
// (In other words, the coordinates currently occupied by this car are in the interval from positions[i] to positions[i]+lengths[i].)
//
// Moving a single car one meter in either direction costs Janusz one unit of energy.
// Compute the smallest total amount of energy sufficient to push all cars together.
// In the final configuration the cars must be located one after another with no gaps between them.
//
// (Note that there is no restriction on the movement of cars or on the final position of the train.
// Janusz may push the cars in any order, and he may even push some cars by a non-integer number of meters if he wants to.)
//
//
// DEFINITION
// Class:ConnectingCars
// Method:minimizeCost
// Parameters:vector <int>, vector <int>
// Returns:long long
// Method signature:long long minimizeCost(vector <int> positions, vector <int> lengths)
//
//
// NOTES
// -You may assume that the optimal answer is always an integer that fits into a signed 64-bit integer data type.
//
//
// CONSTRAINTS
// -lengths and positions will have the same number of elements.
// -lengths will have between 2 and 50 elements, inclusive.
// -Each element of lengths and positions will be between 1 and 10^9, inclusive.
// -The segments occupied by the cars may touch but they will not overlap.
//
//
// EXAMPLES
//
// 0)
// {1, 3, 10, 20}
// {2, 2, 5, 3}
//
// Returns: 15
//
// There are four cars.
// The intervals currently occupied by the cars are (1,3), (3,5), (10,15), and (20,23).
// In one optimal solution Janusz would move each of the first two cars three meters to the right, the third car two meters to the left, and the fourth car seven meters to the left.
// At the end, the cars occupy the intervals (4,6), (6,8), (8,13), and (13,16).
// Total energy spent: 3+3+2+7 = 15.
//
// 1)
// {100, 50, 1}
//
// {10, 2, 1}
//
// Returns: 96
//
// There are three cars.
// The gaps between consecutive cars have 48 meters each.
// The best solution is to keep the middle car in place and to push the other two towards it.
// This requires 48+48 = 96 units of energy.
//
// 2)
// {4, 10, 100, 13, 80}
// {5, 3, 42, 40, 9}
//
// Returns: 66
//
//
//
// 3)
// {5606451, 63581020, 81615191, 190991272, 352848147, 413795385, 468408016, 615921162, 760622952, 791438427}
// {42643329, 9909484, 58137134, 99547272, 39849232, 15146704, 144630245, 604149, 15591965, 107856540}
//
// Returns: 1009957100
//
//
//
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
