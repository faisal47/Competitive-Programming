#include <bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
#define inf 1<<28
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pli pair<ll,int>
#define pil pair<int,ll>
#define pi acos(-1)
#define fs first
#define sc second
#define pob pop_back
#define vec_ vector
#define clr(a) a.clear()
#define pb push_back
#define eps 1E-7
#define all(a) a.begin(),a.end()
#define allr(a) a.rbegin(),a.rend()
#define fop   freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#define sz(a) (int)a.size()
#define ll long long
#define dd double
#define rep(i,n) for(int i=0;i<n;i++)
#define rep1(i,n) for(int i=1;i<=n;i++)
#define repa(i,n) for(auto i:n)
using namespace std;

template<class T1> void deb(T1 e)
{
    cout<<e<<endl;
}
template<class T1,class T2> void deb(T1 e1,T2 e2)
{
    cout<<e1<<" "<<e2<<endl;
}
template<class T1,class T2,class T3> void deb(T1 e1,T2 e2,T3 e3)
{
    cout<<e1<<" "<<e2<<" "<<e3<<endl;
}
template<class T1,class T2,class T3,class T4> void deb(T1 e1,T2 e2,T3 e3,T4 e4)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<endl;
}
template<class T1,class T2,class T3,class T4,class T5> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<endl;
}
template<class T1,class T2,class T3,class T4,class T5,class T6> void deb(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5,T6 e6)
{
    cout<<e1<<" "<<e2<<" "<<e3<<" "<<e4<<" "<<e5<<" "<<e6<<endl;
}
//template <class T> T lcm(T a, T b){return (a/__gcd(a,b)) * b;}
//ll bigmod(ll a,ll b,ll m){if(b == 0) return 1%m;ll x = bigmod(a,b/2,m);x = (x * x) % m;if(b % 2 == 1) x = (x * a) % m;return x;}
//double dur(int x1,int y1,int x2,int y2)
//{
//    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
//template<class T> string toString(T n){ostringstream oss;oss<<n;oss.flush();return oss.str();}
//int toInt(string s){int r=0;istringstream sin(s);sin>>r;return r;}
//struct point{int x, y; point () {} point(int a, int b) {x = a, y = b;}};
//int X[]={0,-1,-1,-1,0,1,1,1};
//int Y[]={-1,-1,0,1,1,1,0,-1};
//int X[]={-1,0,1,0};
//int Y[]={0,1,0,-1};

#define mt
#define mod

map<vector<int>,int>ma;
queue<vector<int>>q;
int mots;

map<vector<int>,int>par;
map<vector<int>,vector<int>>par2;

bool check(vector<int>d)
{
    if(sz(d) != mots || ma.find(d)!=ma.end())
        return 0;
    repa(num,d)
    if(num < 0 || num>10)
        return 0;
    return 1;
}

vector<int> go1(int s,vector<int>d)
{
    vec_<int>hua;
    int ache=d[s];
    d[s]=0;
    if(!ache)
        return hua;
    while(ache > 0)
    {
        s=(s+1)%sz(d);
        d[s]++;
        ache--;
    }
    return d;
}

vector<int> go2(int s,vector<int>d)
{
    vec_<int>hua;
    int nisi=0;
    if(d[s]==0)
        return hua;
    while(d[s]>0)
    {
        nisi++;
        d[s]--;
        s=(s-1 + sz(d))%sz(d);
    }
    d[s]=nisi;
    return d;
}


vector<int>mhua;

void make_clear()
{
    clr(ma);
    clr(mhua);
    clr(par);
    clr(par2);
}

void dfs(vector<int>v)
{
    if(par[v]==-1)
        return;
    mhua.pb(par[v]);
    dfs(par2[v]);
}

vector<int> bfs(vector<int>s,vector<int>e)
{
    mots=sz(s);
    while(!q.empty())q.pop();
    ma[s]=0;
    q.push(s);
    par[s]=-1;
    vector<int>u;
    while(!q.empty())
    {
        s=q.front();
        q.pop();
        if(s == e)
            break;
        if(ma[s]>=2500)
            continue;
        rep(j,2)
        {
            if(j==0)
            {
                rep(i,sz(s))
                {
                    u=go1(i,s);
                    if(check(u))
                    {
                        q.push(u);
                        ma[u]=ma[s]+1;
                        par2[u]=s;
                        par[u]=i;
                    }
                }
            }
            else
            {
                rep(i,sz(s))
                {
                    u=go2(i,s);
                    if(check(u))
                    {
                        q.push(u);
                        ma[u]=ma[s]+1;
                        par2[u]=s;
                        par[u]=i+sz(s);
                    }
                }
            }
        }
    }
    dfs(e);
    reverse(all(mhua));
    return mhua;
}

class ReverseMancala
{
public:
    vector <int> findMoves(vector <int> start, vector <int> target)
    {
        return bfs(start,target);
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, vector <int> p2)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    ReverseMancala *obj;
    vector <int> answer;
    obj = new ReverseMancala();
    clock_t startTime = clock();
    answer = obj->findMoves(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "{";
        for (int i = 0; int(p2.size()) > i; ++i)
        {
            if (i > 0)
            {
                cout << ",";
            }
            cout << p2[i];
        }
        cout << "}" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "{";
    for (int i = 0; int(answer.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << answer[i];
    }
    cout << "}" << endl;
    if (hasAnswer)
    {
        if (answer.size() != p2.size())
        {
            res = false;
        }
        else
        {
            for (int i = 0; int(answer.size()) > i; ++i)
            {
                if (answer[i] != p2[i])
                {
                    res = false;
                }
            }
        }
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    vector <int> p0;
    vector <int> p1;
    vector <int> p2;

//    {
//        // ----- test 0 -----
//        int t0[] = {6,3,4,0};
//        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//        int t1[] = {1,5,6,1};
//        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
//        int t2[] = {0};
//        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
//        all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
//        // ------------------
//    }
//
//    {
//        // ----- test 1 -----
//        int t0[] = {1,5,6,1};
//        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//        int t1[] = {6,3,4,0};
//        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
//        int t2[] = {6};
//        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
//        all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
//        // ------------------
//    }
//
//    {
//        // ----- test 2 -----
//        int t0[] = {10,0,1,2,3};
//        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//        int t1[] = {10,0,0,2,4};
//        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
//        int t2[] = {2,4,8};
//        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
//        all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
//        // ------------------
//    }
//
//    {
//        // ----- test 3 -----
//        int t0[] = {2,0,1,7};
//        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//        int t1[] = {0,2,1,7};
//        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
//        int t2[] = {2,0,1,7};
//        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
//        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
//        // ------------------
//    }
//
//    {
//        // ----- test 4 -----
//        int t0[] = {3,2,4,5};
//        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
//        int t1[] = {0,1,6,7};
//        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
//        int t2[] = {7,1,0,7,1,0};
//        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
//        all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
//        // ------------------
//    }

    {
        // ----- test 5 -----
        int t0[] = {2,1,6,4,5,2,4,5,3,0};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {6,4,8,0,2,6,0,1,3,2};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {10,8,2,16,19,2,4,11,7,6,12,19,14,14,15,3,4,17,11,3,9,16,4,8,13,12,11,9,17,12,19,4,9,8,10,2,0,17,10,3,4,8,16,0,19,15,7,6,17,6};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 6 -----
        int t0[] = {3,4,6,7,2,2,3,9,4,6};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {6,0,5,10,10,3,1,2,8,1};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {8,14,1,12,11,4,9,10,15,16,2,19,2,16,17,11,16,0,12,7,4,5,17,14,0,5,13,3,7,10,12,1,16,14,1,9,1,8,7,5,5,11,19,16,18,1,15,10,16,1};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        all_right = KawigiEdit_RunTest(6, p0, p1, true, p2) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// END KAWIGIEDIT TESTING




//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
